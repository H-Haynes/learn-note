# 数据传递

## 组件之间的数据传递

vue组件之间的数据传递是通过属性传递，但是需要提前注册这个属性，注册属性需要将属性在Vue的props属性中注册
如果组件想要使用vue实例的data里面的属性，则需要进行绑定，使用`:属性=data`的属性来绑定，但是别忘了注册
传值限定:如果要对传入的值进行类型限定，则需要将props的方式改为对象

## 父向子的数据传递

### 按层依次传递

可以通过上面的组件间的传递方式，将数据传递给子组件，而这些属性可以通过子组件再次传递给孙组件，子、孙组件需要预先注册这些属性

或使用`$attr`,代表了未注册的属性,可以通过该属性，继续向下传递

更简洁的方式是在子组件给孙组件传值时，使用 `v-bind="$attrs"`
注意未注册的属性会在行间显示出来，需要使用`inheritAttrs:false`属性来隐藏

### 越级传递

可以使用`$parent`来获取父组件实例上的数据
也可以通过`$children`来拿到子组件的实例,注意生命周期，应在挂载完成后
层级过深这两个属性就不建议使用了

在父组件定义一些值，子孙组件能够直接使用，那么需要的是`provide`属性和`inject`属性
将属性定义在`provide`，在子孙组件的`inject`将要使用的属性列举出来（数组）
也不建议使用
但该方式载Vue3中会较为常用

## 子向父的数据传递

如果在行间某个dom加上`ref`属性，那么在`vue`实例中可以通过`this.$refs.ref`名拿到这个`dom`
**注意：如果给多个dom设置相同的 ref,那么执行的是后盖前操作，并不会处理成数组，但是通过v-for的话，那么会处理成数组**

ref如果放在组件上，那么返回的就是组件实例而不是dom了，这样就能轻松获取这个组件的属性方法等
自定义组件是没有事件的，所以加事件不会触发，需要加上修饰符`.native`使其拥有原生dom的功能
和`$attrs`类似的有*`$listeners`，包含了父作用域所有`v-on`绑定的事件，也可以用`v-on="$listeners"`  传递给内部的组件（`v-bind="$attrs"`也是这样处理的）
组件主动触发事件：`this.$emit("事件名",处理函数参数)` 事件名也可自定义

## 兄弟组件之间的数据通信

一种糟糕的方式是兄弟A将数据传递给父组件，由父组件传递给兄弟B组件,如果A想传给B的子组件，B的子组件想传给A的子组件 ..这种糟糕的方式的确糟糕至极
vue对于这种情况提供的是一种叫做`event bus（事件总线）`方式:

```text
    兄弟A触发某个事件，而兄弟B监听这个事件，当触发时，兄弟A将数据以参数的方式传递，这样兄弟B就能得到数据了
```

在Vue的原型上添加某个属性，值为一个vue实例，组件每次触发这个实例的事件,另一个则监听这个事件

## 组件之间的相互通信

如果父组件将值传递给子组件，而子组件去改变了这个值，这种操作是很危险的，vue会出现警告(这就是**单向数据流**)

+ 父组件将数据传递给子组件
  + 子组件在使用时，创建一个变量等于这个值，在改变之后$emit一个事件，将数据传递出去
  + 父组件@on 这个事件，得到这个数据，然后进行处理
  + 这样就完成了组件的相互通信 

+ 实际上数据传递直接使用v-model也能完成
+ `:数据传递 + @事件监听 = :数据传递.sync="属性"`
  + `:value + @input = v-model`
  + `:value + @update:value =.sync`
