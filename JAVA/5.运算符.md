# 运算符

[toc]

## 自增自减

```
    int a = 1;
    a = a++;
    a = ?   //1
```

变量赋值的过程（不只是针对自增）：
上面的过程中，a++也就是`a = a+1;`,将a变量空间的内容先取出，然后到常量区取出1，进行计算，然后再次存回a空间
a在想要做值交换时(计算,变化)，会产生一个**临时副本空间(备份)**
**++在前时，先自增后备份，++在后时，先备份后自增**
赋值时，将副本空间的值赋予给a变量，并销毁副本空间，这就是为什么a = 1;

```
    int x = 1;
    // x += 2;  //3
    x = x + 2;  //3;

    byte x = 1;
    // x += 2; // 3
    x = x+2; //编译错误，会有类型转化(int => byte),应(byte)(x+2)
```

x变量空间的值1取出来，再从常量区取出2，将他们相加，并将结果存回x;
x取出的为byte (8bit),常量区取出的为int (32bit),因此出现了类型不同的问题
`00000001 + 00000000 00000000 00000010`
被转换为
`00000000 00000000 00000001 + 00000000 00000000 00000010`
最终结果为32bit的int类型3，赋值到8bit的byte时报错

为何x+=2不会？
byte x = 1时，=号将32位的1自动转化为了byte，
+= 计算时，+号自动类型提升值为32位int,计算完由于+和=一起的，=号再次自动转化byte
而x = x+2,两个符号互不相干，不进行自动转化,因不确定后面的值是什么

## instanceOf

检查一个值是否 属于某个数据类型


## 逻辑运算

&逻辑与     并且
|逻辑或     其中一个成立
^逻辑异或   前后结果不一致则成立
!逻辑非     取反（单目）
&&短路与    前面的条件不成立的，返回false,后面的条件不再执行;若执行完全部为true,结果为true  执行结果和&无区别，只有短路时，才会有性能提升
||短路或    前面的条件成立的条件，返回true,后面条件不再执行;若执行完，全部为false,结果为false.执行结果和| 无区别，只有短路时，才会有性能提升

## 位运算

### 进制转化

**10进制转为2进制**：```num % 2```将余数倒序排列
**2进制转为10进制**:num从右向左，每个乘以2（^位置）次幂
,将结果相加

将二进制数，每三个bit合成一个，计算成10进制，最终**合成**(拼接)一个短的数据，前面加上0,这就是**八进制**，三个bit最大值为111，转为10进制为7，所以叫8进制

```111,100 -> 7 4 -> 074 八进制```

将二进制数，每四个bit合成一个，计算成10进制，并将大于9的使用字母代替，最终合成一个短的数据，前面加上0x,这就是**十六进制**,四个bit最大值为1111，转换为10进制为15,对应字母F,由此而来

```11,1100 -> 3 12 -> 3c => 0x3c 十六进制```

### 位运算规则

将两个值转换为2进制，按位比较他们的值,将最终结果转换为10进制，就是最终结果

+ & 按位与
  + 1为true,0为false,按位进行"与"比较
  + `3&5`: `011 & 101` -> `001` -> `1`
+ | 按位或
  + 1为true， 0为false.按位进行或比较
  + `3&5`: `011 | 101` -> `111` -> `7`
+ ^ 按位异或
  + 按位相同为0,不同为1
  + 异或同一个数字两次，值为本身
  + `3^5`: `011 ^ 101` -> `110` -> `6`
+ ~ 按位取反 单目运算符
  + 1为0，0为1
  + `~3`: `011` -> `100` ->`4`
  + `~6`: -7
+ << 按位左位移
  + 乘以2的位移次幂
  + `6<<2`: `00000000 0000000 00000000 00000110` -> `00000000 00000000 00011000` -> 24
+ [>>] 按位右位移
  + 除以2的位移次幂，保留符号位置
  + `6>>2` -> `00000000 0000000 00000000 00000110` -> `00000000 00000000 00000000 00000001` -> 1
  + `-6>>1`: `11111111 111111111 11111111 11111010` -> `?1111111 111111111 111111111 11111101`
+ [>>>] 按位右位移 (无符号)
  + 不保留符号，不论什么都填0

示例数：6  ,     -6
原码:`00000000 00000000 00000110`,
    `10000000 00000000 00000110`  //**负数第一位为符号**
反码:`00000000 0000000 000000110`,
    `11111111 1111111 11111001`, //**负数反码：符号不变，其余取反**
补码:`00000000 0000000 000000110`,
    `11111111 11111111 11111010`,//**负数补码即负数反码+1**，负数时，0归负数那一半，所以要+1
计算机中不论整数还是负数，都是以补码存储

## 值的交换

1. 使用中间变量

```
  int a =1;
  int b = 2;
  int c =a;
  a =b;
  b = c
```
弊端：内存浪费

2. 差值计算

```
  int a =1;
  int b = 2;
a = a+b;
b = a -b ;
a = a - b;
```
弊端：可能越界

3. 位运算

```
    int a =1;
    int b = 2;
    a = a^b;
    b = a^b;    //异或两次，为原来的值
    a = a^b;    //为异或第一次后，再异或两次，为第一次异或的值
```