# 打包优化

[toc]

## tree shaking

将没有使用的代码抖掉，包括Js/css，没有使用到的模块、没有使用到的模块导出方法

### js

`lodash-es`工具集
`webpack-deep-scope-plugin`: webpack无作用域判断，如果另一个依赖同名，可能会导致整个文件被打包，该插件可处理此问题

## css

`mini-css-extract-plugin`: 单独将css样式代码抽离,使用到的loader：`MiniCssExtractPlugin.loader,css-loader`
`purifycss-webpack`: 将无用的样式抖掉

```javascript
    const PurifyCssWebpack = require("purifycss-webpack")
    module.export = {
        new PurifyCssWebpack({
            paths:glob.sync(path.join(__dirname,`/app/\*.html`))
            // css 抖动需在js抖动之前，否则会报错
        })
    }
```

`postcss`工具集:

+ `autoprefixer` 自动添加浏览器前缀
+ `cssnano` css压缩
+ `postcss-cssnext` 添加对未来版本css支持
  
### html

`html-webpack-plugin`: 根据原js文件和模板html生成html,并自动引入js,css
`clear-webpack-plugin`: 清理之前打包结果的，仅保留本次，

```javascript
    const HtmlWebpackPlugin = require("html-webpack-plugin")
    const clearWebpackPlugin = require("clear-webpack-plugin")
    module.export = {
        plugins:[
            new HtmlWebpackPlugin({
                filename:"index.html", //生成的目标html文件
                template:"./public/template.html", // 模板文件
                minify:{
                    removeComment:true, //移除注释
                    collapseWhitespace:true, // 清除空白
                }
            }),
            new ClearWebpackPlugin();
        ]
    }
```

### 图片/文件

常用两个loader来处理:`url-loader`,`file-loader`,在webpack5中，他们被`assets-loader`取代

```javascript
    module.exports = {
        module:{
            rules:[
                {
                    test:/\.(jpg|png|jpeg|gif)$/,
                    use:[
                        {
                            loader:'url-loader',
                            options:{
                                name:"[name][hash:5].[ext]", //输出文件名
                                limit:10000,    //限制图片大小，小于该值转为base64,否则输出文件到指定目录
                                outputPath:"/src/img"
                            }
                        },
                        {
                            loader:"img-loader"
                        }
                    ]
                }
            ]
        }
    }
```

## 提取公共js optimization

该项为webpack4增加，低于4无此项

```javascript

    module.export = {
        optimization:{
            splitChunks:{
                cacheGroups:{ // 提取公用的模块
                    common:{
                        name:"common", //模块名,
                        chunks:"all", //在哪些范围内
                        miniSize:1, //最小的包大小
                        minChunks: 2 ,//当前这个公共模块出现的最小次数
                    },
                    vendor:{ // 提取第三方库
                        name:"vendor",
                        test:/[\\/]node_modules[\\/]/, // 仅匹配node_modules的模块
                        priority:10 ,  //优先级
                        chunks:"all"
                    }
                }
            }
        }
    }
```

## 不解析模块 noParse

模块不进行解析，源码即结果
条件：模块中无其他依赖，一些已经打包好的第三方库，如jquery

## 优化loader性能

### 减少loader应用范围

对于某些库，不使用loader,如使用es5编写的库

```javascript
    module.exports = {
        modules:{
            rules:[
                {
                    test:/\*.js$/,
                    exclude:/lodash/, //对lodash库不进行babel-loader处理，因为它使用es3书写的，无需处理
                    //exclude:/node_modules/, //排除所有node_modules的库
                    //include:/src/, //仅对src下所有js处理
                    use:'babel-loader'
                }
            ]
        }
    }
```

### 缓存loader结果 cache-loader

文件不变的情况下，缓存loader结果,使用cache-loader,将cache-loader放在第一位loader(loader是自右向左执行的)

第一次较慢，因为要进行缓存

### loader多线程 thread-loader

thread-loader会开启一个线程池，包含适量的线程
会把后续的loader放到线程池运行
后续loader无法使用以下操作:

1. webpack api生成文件
2. 无法使用自定义plugin api
3. 无法访问webpack options

小项目开启thread-loader反而会降低效率，开启多线程需要时间的
