# 执行期上下文（预编译）

[toc]

## 前导知识

### stack(栈)

 栈可以看做一个桶，将数据放在这个桶里面。最先放进来的就是栈底，最后放进来的就是栈顶（==**后进先出**==）。放数据进来的过程被称为入栈，取出数据被称为出栈

### 对象引用

对象之间的赋值是将其引用地址（存储空间地址）赋值给对方，也就是说对象实际是存储的一个引用地址，这个地址指向某个储存空间

## 概念

某个函数或者全局代码的执行环境，该环境包含执行代码所需要的所有信息,可以看做一个对象。
当**执行**一个函数时，需要先建立执行期上下文，然后才真正执行,JS程序的执行，至少会有一个执行期上下文（全局）

**call Stack**(执行期上下文栈):组织管理程序运行过程中的执行期上下文，程序运行时必定会有很多执行期上下文

实例: 

        var i = 23;
        function p(){
            a =7;
            fucntion x(){
                console.log(a)
            }
           x();
           console.log("Test")
        }
        
        function q(){
            p();
            a =22;
            function z(){
                alert("Test2")
            }
           z()
        }
        q()
    先建立全局执行期上下文；
    然后是q函数执行（记住执行才会有执行期上下文）；
    q函数调用p函数，建立p函数执行期上下文;
    p函数调用x函数，建立x执行其上下文
    （系统函数console.log就不再此列出了）
    q函数调用z函数，建立z函数执行期上下文.
    所以最后的执行栈是这样的:
               | z函数执行其上下文 |  栈顶
               | x函数执行期上下文 |
               | p函数执行期上下文 |
               | q函数执行期上下文 |
               | 全局函数执行上下文|   栈底
                __________________
    执行后依次出栈

## 执行期上下文的内容

1. VO:variable object ,变量对象，存放的是函数或者全局代码执行过程中需要用到的局部变量
2. Scope : 作用域
3. this  

预编译四部曲:
    1. 创建AO,
    2. 找形参和变量声明，挂载至AO
    3. 形参实参相统一，在AO中赋值
    4. 找到函数声明，将函数挂载至AO（存在直接覆盖,如果是声明，函数总是最高级的）
期间同名直接覆盖
